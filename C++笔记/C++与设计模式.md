# C++与设计模式

最常用的5个设计原则

1. SRP，单一职责
   
   简单来说就是**不要做多余的事**，高内聚低耦合。在设计类时，要尽量缩小“粒度”，功能明确单一。例如，使用工厂来分类创建对象、使用适配器、装饰、代理来组合对象、使用外观来封装批量的对象。

2. OCP，开闭原则
   
   **对扩展开放，对修改关闭**，做好封装，隐藏内部的具体实现细节，然后开放足够的接口。例如，迭代器模式让集合保持稳定的方式只需变动迭代器

3. LSP，里氏替换
   
   **子类必须能够完全替代父类**，子类不能改变、违反父类定义的行为

4. ISP，接口隔离
   
   **尽量简化、归并给外界调用的接口**。

5. DIP，依赖反转/依赖倒置
   
   **上层要避免依赖下层的实现细节，下层要反过来依赖上层的抽象定义**。其实就是解耦

## 创建型模式

### 工厂模式

```cpp
auto ptr1 = make_unique<int>(42);
auto ptr2 = make_shared<string>("test");
```



## 结构型模式

结构型模式有7个，分别为适配器、外观、代理、桥接、组成、装饰、享元

### 适配器模式

适配器模式的目的是接口转换，不需要修改源码，就能把一个对象转换为可以在本系统中使用的形式。

```cpp
array<int, 5> arr = {0, 1, 2, 3, 4};

auto b = begin(arr);
auto e = end(arr);

for_each(b, e, [](int){...});
```

### 外观模式

外观模式封装了一组对象，目的是简化这组对象的通信关系，提供一个高层次的易用的接口，让外部用户更容易使用，降低系统的复杂度。

```cpp
auto f = std::async([](){...});
f.wait();
```

async中封装了线程的创建、调度等细节

### 代理模式

在C++中的例子为智能指针，它代替了原始指针，限制了某些危险操作，并且添加了自动生命周期管理。

## 行为模式
