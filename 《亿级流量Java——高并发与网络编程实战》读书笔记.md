## 系统分析

**分布式系统中的幂等性原则？**

在使用消息队列和异步调用时，需要考虑幂等性问题，即对于一个操作的对此重复请求，应该返回相同的结构。

- 在写操作之前执行读操作判断订单状态。
- 添加“去重表”实现幂等性
  - 每一个操作在第一次执行时，会生成一个全局ID，如订单ID
  - 在去重表中查询订单ID是否存在
  - 如果存在，直接返回结果；如果不存在，再执行核心操作（如支付），并将该订单ID存入去重表中，最后返回结果。
- CAS算法、分布式锁、悲观锁

**幂等性与表单重复提交区别：**

主要区别时用户操作意图不同：幂等性是由于网络等故障，用户不知道第一次操作是否成功，发送了多次重复请求；表单重复提交是在获知第一次请求成功后，由于误操作等原因再次发送了请求。表单重复提交的问题可以通过***Token令牌机制、PRG模式、数据库唯一约束***等方法避免表单的重复提交问题。

**在系统设计阶段需要提前规避的一些问题：**

- Session共享问题
- 优先考虑无服务状态
- 技术选型原则与数据库设计
- 缓存穿透与缓存雪崩问题

## 高并发相关JVM和JDK

[详见Java笔记](https://github.com/MacroYuan/Notes/blob/main/Java%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0%20Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.md)

## 解析多线程并发包

**CopyOnWrite, ReadWriteLock, ConcurrentHashMap, BlockQueue, CoutDownLatch**

//TODO

## 远程调用

**RPC和thrift**

## NIO聊天室实战

#### I/O设计核心思想——装饰模式

装饰模式是指在不影响原有对象的情况下，动态地、无侵入地给一个对象添加一些额外的功能。如Java的`File`和`FileInputStream`，`FileInputStream`就是`File`对象的封装，该对象包含了原`File`对象和原字符串的内容。

### NIO

## NIO框架——Netty

//TODO

## RPC框架

### thrift

### gRPC

