正则表达式(regular expression)是描述一种字符串的匹配(pattern)，一般用来检测一个串是否含有某种字串、将匹配的子串替换掉或者从某个串中取出符合某个条件的子串等。

# 特别字符

| 特别字符 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| $        | 匹配字符串的结尾位置                                         |
| ^        | 匹配字符串的开始位置                                         |
| .        | 匹配除换行符\n之外的任何字符，一个.表示一个其他字符          |
| +        | 匹配前面的子表达式一次或多次                                 |
| *        | 匹配前面的子表达式零次或多次                                 |
| ()       | 标记一个子表达式开始和结束的位置                             |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符         |
| \        | 将一个字符标记为特殊字符、或原义字符、或向后引用、或八进制转义符 |
| \|       | 指明两项之间的一个选择                                       |
| [        | 标记一个中括号表达式的开始                                   |
| {        | 标记限定符表达式的开始                                       |



# 非打印字符

非打印字符可以是正则式的组成部分。

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| \n   | 匹配一个换行符，等价于\x0a和\cJ                              |
| \f   | 匹配一个换页符，等价于\x0c和\cL                              |
| \cx  | 匹配由x指明的孔子字符，如\cM匹配一个Control-M或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \r   | 匹配一个回车符，等价于\x0d和\cM                              |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v] |
| \S   | 匹配任何非空白字符，等价于\[^\f\n\r\t\v]                     |
| \t   | 匹配一个制表符，等价于\x09和\cI                              |
| \v   | 匹配一个垂直制表符，等价于\x0b和\cK                          |



# 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。

| 字符  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 匹配前面的子表达式零次或多次，如zo*能匹配z和zoo              |
| +     | 匹配前面的子表达式一次或多次，如zo+能匹配zo和zoo，但不能匹配z |
| ?     | 匹配前面的子表达式零次或一次，如do(es)?能匹配do、does、doxy  |
| {n}   | n是一个非负整数，匹配确定的n次                               |
| {n,}  | n是一个非负整数，至少匹配n次                                 |
| {n,m} | m和n都是非负整数，其中n<=m，至少匹配n次，最多匹配m次         |



# Java

在Java中使用正则式进行字符串匹配，需要使用到java.util.regex.*包

```java
String s = "test string";
String pattern = ".*ing.*";

boolean isMatch = Pattern.matches(pattern, s);
System.out.println("字符串中是否包含‘ing’子串" + isMatch);
```

```java
String s = "This order was placed for QT3000! OK?";
String pattern = "(\\D*)(\\d+)(.*)";

Pattern r = Pattern.compile(pattern);

Matcher m = r.matcher(s);
if (m.find()) {
    // 该方法将被匹配串分为捕获组，就是匹配串匹配了多少次
    m.group(0); //原串本身
    m.group(1); //捕获(\\D*)
    m.group(2); //捕获(\\d+)
    m.group(3)； //捕获(.*)
} else {
    System.out.println("NOT MATCH");
}
```



# JavaScript

```javascript
/a/.test("javascript")
/正则式串/.test("待匹配串")
```

## 匹配前瞻

`exp1(?=exp2)`：匹配exp2前面的exp1，匹配结果不包含exp2

## 匹配后顾

`(?<=exp2)exp1`：匹配exp2后的exp1，匹配结果不包含exp2

## 匹配非

`/[^a]/`：这里中括号里的^是取反的意思，不再是表示字符串起始位置

### 负前瞻

`exp1(?!exp2)`：匹配后面不是exp2的exp1，匹配结果不包含exp2

### 负后顾

`(?<!exp2)exp1`：匹配前面不是exp2的exp1，匹配结果不包含exp2

### 匹配不包含连续abc的串

1. 匹配位置后面不能是abc，使用负前瞻匹配这样的位置：`/(?!abc)/`

2. 这个位置后面可以是其他的字符，用`\w`来表示：`/(?!abc)\w/`

3. 满足上面情况后的位置，可以连续多次，用`+`来表示数量：`/((?!abc)\w)+/`

4. 从开始到结束每个位置都要覆盖到，添加开始结束标记：`/^((?!abc)\w)+$/`

`/^((?!abc))\w)+$/`